

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="https://raw.githubusercontent.com/Luyoung0001/picBed/main/low.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luyoung">
  <meta name="keywords" content="">
  
    <meta name="description" content="Box 的核心概念1. 堆分配 Box 将数据存储在堆上而不是栈上 栈上只保留指向堆数据的指针 解决栈空间有限的问题，特别是对于大对象  2. 所有权机制 Box 遵循 Rust 的所有权规则 当 Box 离开作用域时，会自动释放其内存 实现 Drop trait，确保内存安全  1234&#123;    let b &#x3D; Box::new(5); &#x2F;&#x2F; 在堆上分配    &#x2F;&#x2F; 使用 b...&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust:Box、match、ownership">
<meta property="og:url" content="http://blog.luliang.online/2025/09/27/Rust%EF%BC%88%E4%BA%94%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyoung">
<meta property="og:description" content="Box 的核心概念1. 堆分配 Box 将数据存储在堆上而不是栈上 栈上只保留指向堆数据的指针 解决栈空间有限的问题，特别是对于大对象  2. 所有权机制 Box 遵循 Rust 的所有权规则 当 Box 离开作用域时，会自动释放其内存 实现 Drop trait，确保内存安全  1234&#123;    let b &#x3D; Box::new(5); &#x2F;&#x2F; 在堆上分配    &#x2F;&#x2F; 使用 b...&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-27T07:03:13.000Z">
<meta property="article:modified_time" content="2025-10-30T11:13:34.300Z">
<meta property="article:author" content="Luyoung">
<meta property="article:tag" content="Rust 基础">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Rust:Box、match、ownership - Luyoung</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.luliang.online","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 65vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Luyoung</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.githubusercontent.com/Luyoung0001/picBed/main/1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust:Box、match、ownership"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-27 15:03" pubdate>
          2025年9月27日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          36 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Rust:Box、match、ownership</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Box-的核心概念"><a href="#Box-的核心概念" class="headerlink" title="Box 的核心概念"></a>Box 的核心概念</h2><h3 id="1-堆分配"><a href="#1-堆分配" class="headerlink" title="1. 堆分配"></a>1. 堆分配</h3><ul>
<li><code>Box</code> 将数据存储在<strong>堆</strong>上而不是栈上</li>
<li>栈上只保留指向堆数据的指针</li>
<li>解决栈空间有限的问题，特别是对于大对象</li>
</ul>
<h3 id="2-所有权机制"><a href="#2-所有权机制" class="headerlink" title="2. 所有权机制"></a>2. 所有权机制</h3><ul>
<li><code>Box</code> 遵循 Rust 的所有权规则</li>
<li>当 <code>Box</code> 离开作用域时，会自动释放其内存</li>
<li>实现 <code>Drop</code> trait，确保内存安全</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 在堆上分配</span><br>    <span class="hljs-comment">// 使用 b...</span><br>&#125; <span class="hljs-comment">// b 离开作用域，内存自动释放</span><br></code></pre></td></tr></table></figure>

<h2 id="为什么需要-Box"><a href="#为什么需要-Box" class="headerlink" title="为什么需要 Box"></a>为什么需要 Box</h2><h3 id="1-处理递归类型"><a href="#1-处理递归类型" class="headerlink" title="1. 处理递归类型"></a>1. 处理递归类型</h3><p>Rust 在编译时需要知道类型的大小，但递归类型（如链表）的大小无法在编译时确定：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;), <span class="hljs-comment">// 使用 Box 固定大小</span><br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> List::&#123;Cons, Nil&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br></code></pre></td></tr></table></figure>

<h3 id="2-转移大数据所有权"><a href="#2-转移大数据所有权" class="headerlink" title="2. 转移大数据所有权"></a>2. 转移大数据所有权</h3><p>当需要转移大数据的所有权时，使用 <code>Box</code> 只需复制指针而非整个数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_ownership</span>(data: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;) &#123;<br>    <span class="hljs-comment">// 处理数据...</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">big_data</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">1_000_000</span>]);<br><span class="hljs-title function_ invoke__">take_ownership</span>(big_data); <span class="hljs-comment">// 高效转移所有权</span><br></code></pre></td></tr></table></figure>

<h3 id="3-创建-trait-对象"><a href="#3-创建-trait-对象" class="headerlink" title="3. 创建 trait 对象"></a>3. 创建 trait 对象</h3><p><code>Box</code> 可以存储 trait 对象，实现动态分发：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Drawable</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span>;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drawable</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">shapes</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Drawable&gt;&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Circle)];<br></code></pre></td></tr></table></figure>

<h2 id="Box-的工作原理"><a href="#Box-的工作原理" class="headerlink" title="Box 的工作原理"></a>Box 的工作原理</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell">栈              堆<br>+------+       +-------+<br>| 指针 | ----&gt; | 数据  |<br>+------+       +-------+<br></code></pre></td></tr></table></figure>

<h3 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 创建 Box</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_i32</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_vec</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 访问数据</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, boxed_i32); <span class="hljs-comment">// 自动解引用</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, boxed_vec[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 自动解引用</span><br><br><span class="hljs-comment">// 模式匹配</span><br><span class="hljs-keyword">match</span> *boxed_i32 &#123;<br>    <span class="hljs-number">42</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;It&#x27;s 42!&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Box-的性能特点"><a href="#Box-的性能特点" class="headerlink" title="Box 的性能特点"></a>Box 的性能特点</h2><ol>
<li><p><strong>零开销抽象</strong>：</p>
<ul>
<li><code>Box</code> 本身没有运行时开销</li>
<li>编译后就是普通的指针操作</li>
</ul>
</li>
<li><p><strong>内存成本</strong>：</p>
<ul>
<li>每个 <code>Box</code> 占用一个指针的大小（通常 8 字节）</li>
<li>加上堆分配的开销（分配器元数据）</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>适合中等大小的数据</li>
<li>超大对象考虑其他方案（如内存映射文件）</li>
<li>小对象可能更适合栈分配</li>
</ul>
</li>
</ol>
<h2 id="Box-与其他智能指针对比"><a href="#Box-与其他智能指针对比" class="headerlink" title="Box 与其他智能指针对比"></a>Box 与其他智能指针对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>Box&lt;T&gt;</code></th>
<th><code>Rc&lt;T&gt;</code></th>
<th><code>Arc&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权</strong></td>
<td>单一所有权</td>
<td>共享所有权</td>
<td>线程安全共享</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（Send）</td>
<td>否</td>
<td>是（Send+Sync）</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>最低</td>
<td>引用计数</td>
<td>原子引用计数</td>
</tr>
<tr>
<td><strong>主要用途</strong></td>
<td>堆分配、递归类型</td>
<td>单线程共享数据</td>
<td>多线程共享数据</td>
</tr>
</tbody></table>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li><p><strong>优先使用栈分配</strong>：</p>
<ul>
<li>只在必要时使用 <code>Box</code></li>
<li>小对象和临时变量放栈上</li>
</ul>
</li>
<li><p><strong>避免过度使用</strong>：</p>
<ul>
<li>不要用 <code>Box</code> 包装基本类型（除非必要）</li>
<li>考虑替代方案如 <code>Vec</code> 或数组</li>
</ul>
</li>
<li><p><strong>内存泄漏防范</strong>：</p>
<ul>
<li>避免循环引用（虽然 <code>Box</code> 本身不易泄漏）</li>
<li>使用 <code>Box::leak</code> 时要特别小心</li>
</ul>
</li>
<li><p><strong>与模式匹配结合</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">42</span>));<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(value) = *boxed &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got &#123;&#125;&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题_1:"></a>问题_1:</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> *boxed_i32 &#123;<br>        <span class="hljs-number">42</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;It&#x27;s 42!&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>


<p>这里的 <code>boxed_i32</code> 为什么编译器不能自动插入 *，需要手动写成 <code>*boxed_i32</code>，写成 <code>boxed_i32</code> 就报错？</p>
<p>这个问题涉及到 Rust 中模式匹配的核心机制，以及自动解引用在<code>match</code>表达式中的特殊行为。让我详细解释一下：</p>
<h3 id="根本原因：模式匹配的特殊性"><a href="#根本原因：模式匹配的特殊性" class="headerlink" title="根本原因：模式匹配的特殊性"></a>根本原因：模式匹配的特殊性</h3><p>在 Rust 中，<code>match</code>表达式需要精确的类型匹配，<strong>不会自动解引用</strong>。这是因为：</p>
<ol>
<li><p><strong>模式匹配的本质</strong>：</p>
<ul>
<li><code>match</code> 是解构操作，需要精确知道值的类型</li>
<li>每个分支的模式必须与表达式的类型完全匹配</li>
<li>自动解引用会破坏类型一致性</li>
</ul>
</li>
<li><p><strong>所有权语义</strong>：</p>
<ul>
<li><code>match</code> 会消耗输入值的所有权</li>
<li>自动解引用会改变所有权行为</li>
<li>需要程序员显式决定如何处理所有权</li>
</ul>
</li>
</ol>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><h4 id="错误写法（不能自动解引用）"><a href="#错误写法（不能自动解引用）" class="headerlink" title="错误写法（不能自动解引用）"></a>错误写法（不能自动解引用）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> boxed_i32 &#123; <span class="hljs-comment">// 类型是 Box&lt;i32&gt;</span><br>    <span class="hljs-number">42</span> =&gt; ...     <span class="hljs-comment">// 类型是 i32</span><br>    _ =&gt; ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译器会报错：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mismatched <span class="hljs-keyword">types</span><br>expected `<span class="hljs-type">Box</span>&lt;i32&gt;`, <span class="hljs-built_in">found</span> <span class="hljs-type">integer</span><br></code></pre></td></tr></table></figure>

<h4 id="正确写法（显式解引用）"><a href="#正确写法（显式解引用）" class="headerlink" title="正确写法（显式解引用）"></a>正确写法（显式解引用）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> *boxed_i32 &#123; <span class="hljs-comment">// 显式解引用为 i32</span><br>    <span class="hljs-number">42</span> =&gt; ...      <span class="hljs-comment">// 匹配 i32</span><br>    _ =&gt; ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么不能自动解引用"><a href="#为什么不能自动解引用" class="headerlink" title="为什么不能自动解引用"></a>为什么不能自动解引用</h3><ol>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li><code>Box&lt;i32&gt;</code> 和 <code>i32</code> 是不同类型</li>
<li>Rust 要求模式匹配必须类型精确匹配</li>
<li>自动转换会破坏类型系统的一致性</li>
</ul>
</li>
<li><p><strong>所有权明确性</strong>：</p>
<ul>
<li>解引用 <code>Box</code> 会移动内部值（如果未实现 <code>Copy</code>）</li>
<li>编译器需要你显式确认这个操作</li>
<li>例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br><span class="hljs-keyword">match</span> *s &#123; <span class="hljs-comment">// 显式移动 String 出 Box</span><br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;String moved&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 不能再使用 s</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>模式匹配的灵活性</strong>：</p>
<ul>
<li>你可能需要匹配 <code>Box</code> 本身的结构</li>
<li>例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> boxed_i32 &#123;<br>    b <span class="hljs-keyword">if</span> b == <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>) =&gt; ... <span class="hljs-comment">// 比较整个 Box</span><br>    _ =&gt; ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 <code>match</code> 表达式中需要显式写 <code>*boxed_i32</code> 是因为：</p>
<ol>
<li>模式匹配要求类型精确一致</li>
<li><code>match</code> 会消耗值的所有权</li>
<li>自动解引用会破坏模式匹配的语义</li>
<li>Rust 的设计哲学要求显式处理所有权</li>
</ol>
<h2 id="问题-2-match-会转移所有权对吗，上面的例子怎么不会？"><a href="#问题-2-match-会转移所有权对吗，上面的例子怎么不会？" class="headerlink" title="问题_2: match 会转移所有权对吗，上面的例子怎么不会？"></a>问题_2: match 会转移所有权对吗，上面的例子怎么不会？</h2><p>在 Rust 中 <code>match</code> 表达式通常会转移所有权，但在这个特定例子中，<code>boxed_i32</code> 在 <code>match</code> 后仍然可用。这涉及到 Rust 的所有权系统和 <code>Copy</code> trait 的微妙之处。</p>
<h3 id="关键点：i32-实现了-Copy-trait"><a href="#关键点：i32-实现了-Copy-trait" class="headerlink" title="关键点：i32 实现了 Copy trait"></a>关键点：<code>i32</code> 实现了 <code>Copy</code> trait</h3><p>在上面的代码中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_i32</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">match</span> *boxed_i32 &#123; <span class="hljs-comment">// 解引用 Box 得到 i32</span><br>    <span class="hljs-number">42</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;It&#x27;s 42!&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Something else&quot;</span>),<br>&#125;<br>boxed_i32; <span class="hljs-comment">// 这里仍然可以使用！</span><br></code></pre></td></tr></table></figure>

<h3 id="所有权行为分析"><a href="#所有权行为分析" class="headerlink" title="所有权行为分析"></a>所有权行为分析</h3><ol>
<li><p><strong><code>match</code> 表达式确实会消耗值的所有权</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NonCopy</span>(<span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">NonCopy</span>(<span class="hljs-number">42</span>));<br><span class="hljs-keyword">match</span> *boxed &#123; <span class="hljs-comment">// 消耗 NonCopy 的所有权</span><br>    <span class="hljs-title function_ invoke__">NonCopy</span>(<span class="hljs-number">42</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;OK&quot;</span>),<br>    _ =&gt; (),<br>&#125;<br><span class="hljs-comment">// boxed; // 这里会编译错误：value used after move</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>问题_1例子中为什么可行？</strong></p>
<ul>
<li><code>i32</code> 实现了 <code>Copy</code> trait</li>
<li>当解引用 <code>Box&lt;i32&gt;</code> 时：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">*boxed_i32 <span class="hljs-comment">// 这会产生一个 i32 的副本</span><br></code></pre></td></tr></table></figure></li>
<li><code>match</code> 消耗的是这个副本，而不是原始值</li>
</ul>
</li>
</ol>
<h3 id="具体执行过程"><a href="#具体执行过程" class="headerlink" title="具体执行过程"></a>具体执行过程</h3><ol>
<li><p><strong>解引用操作</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">*boxed_i32 <span class="hljs-comment">// 等价于 Deref::deref(&amp;boxed_i32) 的返回值</span><br></code></pre></td></tr></table></figure>
<ul>
<li>因为 <code>i32</code> 是 <code>Copy</code> 类型</li>
<li>实际产生的是原始值的<strong>位复制</strong>（bitwise copy）</li>
</ul>
</li>
<li><p><strong>模式匹配</strong>：</p>
<ul>
<li><code>match</code> 操作的是这个复制的 <code>i32</code> 值</li>
<li>原始 <code>Box</code> 的所有权保持不变</li>
</ul>
</li>
<li><p><strong>内存示意图</strong>：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">栈 frame:</span><br><span class="hljs-section">+-----------------+</span><br>| boxed_i32: Box  |---+<br><span class="hljs-code">+-----------------+</span>   |<br><span class="hljs-code">                      v</span><br>堆:                <span class="hljs-code">+-----+</span><br><span class="hljs-code">            0x1000 | 42  |</span><br><span class="hljs-code">                   +-----+</span><br><br>match *boxed_i32:<br>1. 从堆复制 42 到栈临时位置<br>2. 匹配临时值<br>3. 原始 Box 不变<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="如果类型不是-Copy"><a href="#如果类型不是-Copy" class="headerlink" title="如果类型不是 Copy"></a>如果类型不是 <code>Copy</code></h3><p>使用非 <code>Copy</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// String 不是 Copy 类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_str</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br><br>    <span class="hljs-keyword">match</span> *boxed_str &#123; <span class="hljs-comment">// 这里会移动所有权！</span><br>        s <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;hello&quot;</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got hello&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Something else&quot;</span>),<br>    &#125;<br><br>    <span class="hljs-comment">// 编译错误！value borrowed here after move</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, boxed_str);</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>错误信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0382]: borrow of moved value: `boxed_str`<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">10</span>:<span class="hljs-number">20</span><br>   |<br><span class="hljs-number">4</span>  |     <span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_str</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>   |         --------- <span class="hljs-keyword">move</span> occurs because `boxed_str` has <span class="hljs-keyword">type</span> `<span class="hljs-type">Box</span>&lt;<span class="hljs-type">String</span>&gt;`, which does not implement the `<span class="hljs-built_in">Copy</span>` <span class="hljs-keyword">trait</span><br>...<br><span class="hljs-number">7</span>  |     <span class="hljs-keyword">match</span> *boxed_str &#123;<br>   |           ---------- `boxed_str` moved due to this usage<br>...<br><span class="hljs-number">10</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, boxed_str);<br>   |                    ^^^^^^^^^ value borrowed here after <span class="hljs-keyword">move</span><br></code></pre></td></tr></table></figure>

<h3 id="为什么这样设计？"><a href="#为什么这样设计？" class="headerlink" title="为什么这样设计？"></a>为什么这样设计？</h3><ol>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>对于小型的 <code>Copy</code> 类型（如 <code>i32</code>），复制成本低于间接访问</li>
<li>避免不必要的堆分配操作</li>
</ul>
</li>
<li><p><strong>所有权语义清晰</strong>：</p>
<ul>
<li>显式解引用 <code>*</code> 明确表示”我要获取内部值”</li>
<li>对于 <code>Copy</code> 类型，这表示”我要复制值”</li>
<li>对于非 <code>Copy</code> 类型，这表示”我要移动值”</li>
</ul>
</li>
<li><p><strong>一致性原则</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x; <span class="hljs-comment">// 复制，x 仍然可用</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = s; <span class="hljs-comment">// 移动，s 不再可用</span><br></code></pre></td></tr></table></figure>
<p><code>match *boxed_i32</code> 的行为与普通赋值一致</p>
</li>
</ol>
<h3 id="如何控制所有权行为"><a href="#如何控制所有权行为" class="headerlink" title="如何控制所有权行为"></a>如何控制所有权行为</h3><table>
<thead>
<tr>
<th>需求</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>保留 Box 所有权</strong></td>
<td>使用 <code>*</code> + <code>Copy</code> 类型</td>
<td><code>match *boxed_i32</code></td>
</tr>
<tr>
<td><strong>移动内部值</strong></td>
<td>使用 <code>*</code> + 非 <code>Copy</code> 类型</td>
<td><code>match *boxed_string</code></td>
</tr>
<tr>
<td><strong>借用内部值</strong></td>
<td>使用 <code>as_ref()</code></td>
<td><code>match boxed_i32.as_ref()</code></td>
</tr>
<tr>
<td><strong>匹配 Box 本身</strong></td>
<td>直接使用</td>
<td><code>match boxed_i32 &#123; ... &#125;</code></td>
</tr>
<tr>
<td><strong>部分匹配</strong></td>
<td>使用 <code>ref</code> 关键字</td>
<td><code>match *boxed_i32 &#123; ref val =&gt; ... &#125;</code></td>
</tr>
</tbody></table>
<h3 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><ol>
<li><p><strong>对于 <code>Copy</code> 类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 直接解引用，安全高效</span><br><span class="hljs-keyword">match</span> *boxed_num &#123;<br>    <span class="hljs-number">42</span> =&gt; ...,<br>    _ =&gt; ...,<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>对于非 <code>Copy</code> 类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 方法1：移动所有权（消耗 Box）</span><br><span class="hljs-keyword">match</span> *boxed_string &#123;<br>    s <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_empty</span>() =&gt; ...,<br>    _ =&gt; ...,<br>&#125;<br><br><span class="hljs-comment">// 方法2：借用内部值（保留所有权）</span><br><span class="hljs-keyword">match</span> boxed_string.<span class="hljs-title function_ invoke__">as_str</span>() &#123;<br>    <span class="hljs-string">&quot;&quot;</span> =&gt; ...,<br>    s =&gt; ...,<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>当需要后续使用 Box 时</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用引用匹配</span><br><span class="hljs-keyword">match</span> &amp;*boxed_string &#123;<br>    <span class="hljs-string">&quot;hello&quot;</span> =&gt; ...,<br>    _ =&gt; ...,<br>&#125;<br><span class="hljs-comment">// boxed_string 仍然可用</span><br></code></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> *boxed_i32 &#123; <span class="hljs-comment">// 复制 i32 值</span><br>    <span class="hljs-number">42</span> =&gt; ...,<br>    _ =&gt; ...,<br>&#125;<br>boxed_i32; <span class="hljs-comment">// 仍然可用，因为：</span><br><span class="hljs-comment">// 1. Box 的所有权从未被转移</span><br><span class="hljs-comment">// 2. 解引用产生的是 i32 的副本</span><br><span class="hljs-comment">// 3. 原始 Box 保持不变</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>这种设计体现了 Rust 的所有权系统的精妙之处：</p>
<ul>
<li>通过 <code>Copy</code> trait 明确区分可复制类型</li>
<li><code>match</code> 的行为与赋值语义保持一致</li>
<li>显式解引用操作符 <code>*</code> 清晰表达了开发者的意图</li>
<li>编译器保证内存安全，同时提供零成本抽象</li>
</ul>
<p>在上面的例子中，<code>boxed_i32</code> 在 <code>match</code> 后仍然可用，正是因为 <code>i32</code> 实现了 <code>Copy</code> trait，解引用操作产生了值的副本，而不是移动所有权。</p>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题_3:"></a>问题_3:</h2><p>Deref trait 的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;**<span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个实现告诉编译器：</p>
<ul>
<li>Box<T> 可以被解引用为 &amp;T</li>
<li>当需要 &amp;T 时，可以直接使用 &amp;Box<T></li>
</ul>
<p>这个不太理解，当我在使用 <code>*Box&lt;T&gt;</code> 的对象的时候，是不是意味着他会调用 <code>deref</code> ，然后返回 <code>&amp;T</code> ?</p>
<h3 id="Box-的-Deref-实现解析"><a href="#Box-的-Deref-实现解析" class="headerlink" title="Box&lt;T&gt; 的 Deref 实现解析"></a><code>Box&lt;T&gt;</code> 的 <code>Deref</code> 实现解析</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;**<span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个实现的核心是：</p>
<ol>
<li>**<code>type Target = T</code>**：声明解引用后的目标类型是 <code>T</code></li>
<li>**<code>deref(&amp;self) -&gt; &amp;T</code>**：定义如何从 <code>&amp;Box&lt;T&gt;</code> 获取 <code>&amp;T</code></li>
</ol>
<h3 id="关键点：-操作符的行为"><a href="#关键点：-操作符的行为" class="headerlink" title="关键点：* 操作符的行为"></a>关键点：<code>*</code> 操作符的行为</h3><p>当使用 <code>*boxed</code> 时（其中 <code>boxed</code> 是 <code>Box&lt;T&gt;</code> 类型），Rust 编译器会执行以下步骤：</p>
<ol>
<li><p>**隐式调用 <code>deref</code>**：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span>: &amp;T = boxed.<span class="hljs-title function_ invoke__">deref</span>(); <span class="hljs-comment">// 调用 Deref::deref(&amp;boxed)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>然后自动解引用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">*tmp <span class="hljs-comment">// 对返回的引用进行解引用</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>所以 <code>*boxed</code> 等价于 <code>*(boxed.deref())</code>，这样就解到了值 <code>T</code> 上。</p>
<h3 id="具体示例分析"><a href="#具体示例分析" class="headerlink" title="具体示例分析"></a>具体示例分析</h3><p>假设有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Box&lt;i32&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="场景-1：直接使用-boxed"><a href="#场景-1：直接使用-boxed" class="headerlink" title="场景 1：直接使用 *boxed"></a>场景 1：直接使用 <code>*boxed</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = *boxed; <span class="hljs-comment">// 等价于 *(boxed.deref())</span><br></code></pre></td></tr></table></figure>
<p>执行过程：</p>
<ol>
<li><code>boxed.deref()</code> 返回 <code>&amp;i32</code>（指向堆上的 42）</li>
<li><code>*</code> 解引用这个 <code>&amp;i32</code>，得到 <code>i32</code> 值 42</li>
<li>因为 <code>i32</code> 是 <code>Copy</code> 类型，值被复制到 <code>value</code>（因此不会转移所有权）</li>
</ol>
<h4 id="场景-2：方法调用中的自动解引用"><a href="#场景-2：方法调用中的自动解引用" class="headerlink" title="场景 2：方法调用中的自动解引用"></a>场景 2：方法调用中的自动解引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, boxed); <span class="hljs-comment">// 不需要显式写 *</span><br></code></pre></td></tr></table></figure>
<p>这里发生的是：</p>
<ol>
<li><code>println!</code> 需要 <code>&amp;i32</code> 作为参数</li>
<li>编译器发现 <code>Box&lt;i32&gt;</code> 实现了 <code>Deref&lt;Target = i32&gt;</code></li>
<li>自动插入解引用：实际调用 <code>println!(&quot;&#123;&#125;&quot;, &amp;**boxed)</code><ul>
<li>第一个 <code>*</code>：<code>*boxed</code> → 通过 <code>deref()</code> 得到 <code>&amp;i32</code></li>
<li>第二个 <code>*</code>：<code>**boxed</code> → 解引用得到 <code>i32</code></li>
<li><code>&amp;</code>：<code>&amp;**boxed</code> → 获取 <code>i32</code> 的引用</li>
</ul>
</li>
</ol>
<h3 id="新的问题："><a href="#新的问题：" class="headerlink" title="新的问题："></a>新的问题：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Box&lt;i32&gt;</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;boxed); <span class="hljs-comment">// 不需要显式写 *</span><br></code></pre></td></tr></table></figure>

<p>为什么写 <code>&amp;boxed</code>、<code>boxed</code> 都可以，也没有警告？？？</p>
<h3 id="Deref-trait-的实现"><a href="#Deref-trait-的实现" class="headerlink" title="Deref trait 的实现"></a><code>Deref</code> trait 的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;**<span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>关键点</strong>：<code>deref()</code> 方法接收 <code>&amp;self</code> 参数，其类型是 <code>&amp;Box&lt;T&gt;</code></li>
<li><strong>返回值</strong>：<code>&amp;T</code>（指向内部数据的引用）</li>
</ul>
<hr>
<h3 id="情况-1：println-boxed"><a href="#情况-1：println-boxed" class="headerlink" title="情况 1：println!(&quot;{}&quot;, &amp;boxed)"></a>情况 1：<code>println!(&quot;&#123;&#125;&quot;, &amp;boxed)</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;boxed);  <span class="hljs-comment">// 显式取引用</span><br></code></pre></td></tr></table></figure>

<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><ol>
<li><p><strong>类型传递</strong>：</p>
<ul>
<li>传递 <code>&amp;boxed</code> → 类型为 <code>&amp;Box&lt;i32&gt;</code></li>
<li>这个类型 <strong>精确匹配</strong> <code>deref()</code> 的 <code>self</code> 参数类型</li>
</ul>
</li>
<li><p><strong><code>deref()</code> 调用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 编译器生成的等效代码</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span>: &amp;<span class="hljs-type">i32</span> = Deref::<span class="hljs-title function_ invoke__">deref</span>(&amp;boxed);<br><span class="hljs-comment">//            ^^^^^^^^^^^^^^</span><br><span class="hljs-comment">//            &amp;Box&lt;i32&gt; 直接传递给 deref()</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>deref()</code> 的 <code>self</code> 参数接收 <code>&amp;Box&lt;i32&gt;</code></li>
<li>在方法内部：<code>&amp;**self</code> → <code>&amp;(*(*self))</code> → 最终返回 <code>&amp;i32</code></li>
</ul>
</li>
<li><p><strong>所有权分析</strong>：</p>
<ul>
<li>整个过程 <strong>没有移动所有权</strong></li>
<li>只是借用 <code>boxed</code> 并返回其内部数据的引用</li>
<li>调用后 <code>boxed</code> 仍然完全有效</li>
</ul>
</li>
</ol>
<hr>
<h3 id="情况-2：println-boxed"><a href="#情况-2：println-boxed" class="headerlink" title="情况 2：println!(&quot;{}&quot;, boxed)"></a>情况 2：<code>println!(&quot;&#123;&#125;&quot;, boxed)</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, boxed);  <span class="hljs-comment">// 直接传递值</span><br></code></pre></td></tr></table></figure>

<h4 id="执行过程：-1"><a href="#执行过程：-1" class="headerlink" title="执行过程："></a>执行过程：</h4><ol>
<li><p><strong>类型传递</strong>：</p>
<ul>
<li>传递 <code>boxed</code> → 类型为 <code>Box&lt;i32&gt;</code></li>
<li>这个类型 <strong>不匹配</strong> <code>deref()</code> 的 <code>self</code> 参数类型（需要 <code>&amp;Box&lt;i32&gt;</code>）</li>
</ul>
</li>
<li><p><strong>编译器插入的转换</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 编译器生成的等效代码</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span>: &amp;<span class="hljs-type">i32</span> = &#123;<br>    <span class="hljs-comment">// 第一步：创建临时引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ref_to_box</span>: &amp;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = &amp;boxed;<br><br>    <span class="hljs-comment">// 第二步：调用 deref()</span><br>    Deref::<span class="hljs-title function_ invoke__">deref</span>(ref_to_box)  <span class="hljs-comment">// 返回 &amp;i32</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>编译器自动插入 <code>&amp;</code> 操作符创建 <code>&amp;Box&lt;i32&gt;</code></li>
<li>然后调用 <code>deref(&amp;boxed)</code> 得到 <code>&amp;i32</code></li>
<li><code>println!</code> 宏总是以引用方式处理参数</li>
<li>即使写 <code>boxed</code>，宏也会自动添加 <code>&amp;</code>，这点是关键，不然无法解释。</li>
</ul>
</li>
<li><p><strong>所有权分析</strong>：</p>
<ul>
<li>创建了 <code>boxed</code> 的 <strong>临时不可变引用</strong></li>
<li><code>deref()</code> 调用后立即释放临时引用</li>
<li><code>boxed</code> 保持完整所有权</li>
<li>调用后 <code>boxed</code> 仍然完全可用</li>
</ul>
</li>
</ol>
<hr>
<h3 id="关键对比表"><a href="#关键对比表" class="headerlink" title="关键对比表"></a>关键对比表</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>&amp;boxed</code> 情况</th>
<th><code>boxed</code> 情况</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传递的类型</strong></td>
<td><code>&amp;Box&lt;i32&gt;</code></td>
<td><code>Box&lt;i32&gt;</code></td>
</tr>
<tr>
<td><strong>匹配 deref()</strong></td>
<td>✅ 直接匹配 <code>self</code> 参数类型</td>
<td>❌ 不直接匹配</td>
</tr>
<tr>
<td><strong>编译器转换</strong></td>
<td>无转换</td>
<td>插入 <code>&amp;</code> 创建临时引用</td>
</tr>
<tr>
<td><strong>deref() 的 self</strong></td>
<td>直接使用您的 <code>&amp;boxed</code></td>
<td>使用编译器创建的临时 <code>&amp;boxed</code></td>
</tr>
<tr>
<td><strong>所有权影响</strong></td>
<td>仅借用，无所有权变化</td>
<td>仅临时借用，无所有权变化</td>
</tr>
<tr>
<td><strong>底层操作</strong></td>
<td><code>deref(&amp;boxed)</code> → <code>&amp;i32</code></td>
<td><code>deref(&amp;(临时引用))</code> → <code>&amp;i32</code></td>
</tr>
<tr>
<td><strong>实际机器码</strong></td>
<td>完全相同的指令序列</td>
<td>完全相同的指令序列</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么两种方式最终结果相同？"><a href="#为什么两种方式最终结果相同？" class="headerlink" title="为什么两种方式最终结果相同？"></a>为什么两种方式最终结果相同？</h3><ol>
<li><p><strong>零成本抽象原则</strong>：</p>
<ul>
<li>Rust 保证两种写法生成的机器码完全相同</li>
<li>临时引用的创建和释放在编译期优化掉</li>
</ul>
</li>
<li><p><strong>自动解引用规则</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">T: Deref&lt;Target = U&gt;<br>⇒ &amp;T 自动转换为 &amp;U<br></code></pre></td></tr></table></figure>
<ul>
<li>两种方式都通过这个规则转换为 <code>&amp;i32</code></li>
</ul>
</li>
<li><p><strong>println! 的隐式行为</strong>：</p>
<ul>
<li><code>println!</code> 宏总是以引用方式处理参数</li>
<li>即使写 <code>boxed</code>，宏也会自动添加 <code>&amp;</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="实际代码验证"><a href="#实际代码验证" class="headerlink" title="实际代码验证"></a>实际代码验证</h3><p>我们可以用显式类型标注来验证：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><br>    <span class="hljs-comment">// 情况 1：显式取引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ref1</span>: &amp;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = &amp;boxed;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">deref_result1</span>: &amp;<span class="hljs-type">i32</span> = ref1.<span class="hljs-title function_ invoke__">deref</span>();<br><br>    <span class="hljs-comment">// 情况 2：直接传递值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ref2</span>: &amp;<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = &amp;boxed; <span class="hljs-comment">// 编译器自动添加这步</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">deref_result2</span>: &amp;<span class="hljs-type">i32</span> = ref2.<span class="hljs-title function_ invoke__">deref</span>();<br><br>    <span class="hljs-comment">// 两种方式获得相同的引用</span><br>    <span class="hljs-built_in">assert_eq!</span>(deref_result1 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>, deref_result2 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;地址相同：&#123;:p&#125; == &#123;:p&#125;&quot;</span>, deref_result1, deref_result2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">地址相同：0x7f8a6bc05d04 == 0x7f8a6bc05d04<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ol>
<li><p>**当您使用 <code>&amp;boxed</code>**：</p>
<ul>
<li>直接传递 <code>&amp;Box&lt;i32&gt;</code> 给 <code>deref()</code></li>
<li>精确匹配方法签名，无需额外转换</li>
</ul>
</li>
<li><p>**当您使用 <code>boxed</code>**：</p>
<ul>
<li>编译器自动插入 <code>&amp;</code> 创建临时引用 <code>&amp;Box&lt;i32&gt;</code></li>
<li>然后调用 <code>deref()</code> 获取 <code>&amp;i32</code></li>
<li>临时引用在表达式结束后立即释放</li>
</ul>
</li>
<li><p><strong>本质相同</strong>：</p>
<ul>
<li>两种方式最终都执行 <code>deref(&amp;boxed)</code></li>
<li>生成完全相同的机器指令</li>
<li>都只涉及借用，不涉及所有权转移</li>
</ul>
</li>
</ol>
<p>这就是 Rust 的自动解引用（Deref Coercion）机制的精妙之处——它让智能指针的使用感觉像直接操作底层数据，同时保持绝对的类型安全和零运行时开销。</p>
<h3 id="为什么设计成这样？"><a href="#为什么设计成这样？" class="headerlink" title="为什么设计成这样？"></a>为什么设计成这样？</h3><p>这种设计实现了：</p>
<ol>
<li><strong>统一访问语法</strong>：无论访问栈数据还是堆数据，都使用相同的 <code>*</code> 语法</li>
<li><strong>零成本抽象</strong>：最终生成的机器码与直接访问内存相同</li>
<li><strong>类型安全</strong>：通过 trait 系统保证解引用操作的安全</li>
</ol>
<h3 id="self-的魔法"><a href="#self-的魔法" class="headerlink" title="&amp;**self 的魔法"></a><code>&amp;**self</code> 的魔法</h3><p>在实现中的 <code>&amp;**self</code> 需要特别解释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>    &amp;**<span class="hljs-keyword">self</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>分解步骤：</p>
<ol>
<li><code>self</code>：<code>&amp;Box&lt;T&gt;</code></li>
<li><code>*self</code>：解引用得到 <code>Box&lt;T&gt;</code>（移动语义）</li>
<li><code>**self</code>：对 <code>Box&lt;T&gt;</code> 解引用得到 <code>T</code>（通过编译器内置行为）</li>
<li><code>&amp;**self</code>：获取 <code>T</code> 的引用</li>
</ol>
<p>实际上，<code>Box&lt;T&gt;</code> 的解引用到 <code>T</code> 是编译器内置操作，<code>deref()</code> 只是暴露这个能力给 trait 系统。</p>
<h3 id="所有权影响"><a href="#所有权影响" class="headerlink" title="所有权影响"></a>所有权影响</h3><p><code>*boxed</code> 的所有权行为取决于 <code>T</code>：</p>
<ul>
<li>如果 <code>T</code> 实现了 <code>Copy</code>（如 <code>i32</code>）：值被复制，原始 <code>Box</code> 不受影响</li>
<li>如果 <code>T</code> 未实现 <code>Copy</code>（如 <code>String</code>）：值被移动，<code>Box</code> 变为空壳（不能再使用）</li>
</ul>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 实现 Copy 的类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_i32</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = *boxed_i32; <span class="hljs-comment">// 复制</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, boxed_i32); <span class="hljs-comment">// 仍然可用</span><br><br><span class="hljs-comment">// 未实现 Copy 的类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_str</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = *boxed_str; <span class="hljs-comment">// 移动所有权</span><br><span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, boxed_str); // 错误！值已被移动</span><br></code></pre></td></tr></table></figure>

<h3 id="自动解引用（Deref-Coercion）规则"><a href="#自动解引用（Deref-Coercion）规则" class="headerlink" title="自动解引用（Deref Coercion）规则"></a>自动解引用（Deref Coercion）规则</h3><p>当需要 <code>&amp;T</code> 而您有 <code>&amp;Box&lt;T&gt;</code> 时，编译器会自动插入解引用链：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_num</span>(n: &amp;<span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-title function_ invoke__">print_num</span>(&amp;boxed); <span class="hljs-comment">// 自动转换为 &amp;(*boxed)</span><br></code></pre></td></tr></table></figure>

<p>转换过程：</p>
<ol>
<li><code>&amp;boxed</code> → <code>&amp;Box&lt;i32&gt;</code></li>
<li>因为 <code>Box&lt;i32&gt;: Deref&lt;Target = i32&gt;</code></li>
<li>编译器插入 <code>Deref::deref(&amp;boxed)</code> → <code>&amp;i32</code></li>
<li>完美匹配函数签名</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><code>*boxed</code> 会：</p>
<ul>
<li>调用 <code>deref()</code> 获取 <code>&amp;T</code></li>
<li>然后解引用该引用获取 <code>T</code></li>
</ul>
</li>
<li><p>当需要 <code>&amp;T</code> 时：</p>
<ul>
<li>可以直接使用 <code>&amp;boxed</code>，编译器自动调用 <code>deref()</code></li>
<li>等价于显式写 <code>&amp;**boxed</code></li>
</ul>
</li>
<li><p><code>Box&lt;T&gt;</code> 的 <code>deref()</code> 实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">&amp;**<span class="hljs-keyword">self</span> <span class="hljs-comment">// 意思是：先解引用 Box，然后获取内部值的引用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>这种设计使得智能指针在使用上几乎与普通引用无区别，同时保持了类型安全和零成本抽象。</p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Rust-%E5%9F%BA%E7%A1%80/" class="print-no-link">#Rust 基础</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust:Box、match、ownership</div>
      <div>http://blog.luliang.online/2025/09/27/Rust（五）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luyoung</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/10/%E9%9D%A2%E8%AF%95%E7%9A%84%E8%AE%B0%E5%BD%951/" title="一场面试的记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一场面试的记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/27/Rust%EF%BC%88%E5%9B%9B%EF%BC%89/" title="Rust:Generics、Traitstor">
                        <span class="hidden-mobile">Rust:Generics、Traitstor</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
